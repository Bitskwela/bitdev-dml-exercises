# Package Management

## Scene: The Mysterious Configuration File

Loy scratches his head, staring at the freshly created Move project folder. Files are scattered everywhere, and he has no idea where to start.

"Mike, I cloned this project but I don't understand what any of these files do," Loy admits, pointing at his screen. "What's this `Move.toml` thing? And why does my module keep saying the address is undefined?"

Mike pulls up a chair, cracking his knuckles. "Alright, let me break it down for you. Every Move project has a structure, and `Move.toml` is the heart of it all—it's like your project's identity card."

"Identity card?" Loy raises an eyebrow.

"Think of it this way," Mike explains. "When you write a module like `module myproject::token`, where does `myproject` come from? It's not magic—it's defined in your `Move.toml` as a **named address**."

Loy's eyes widen. "So that's why I keep getting 'unbound address' errors! I never configured it."

Mike nods. "Exactly. The `Move.toml` tells the compiler three critical things: who you are, what addresses you're using, and what packages you depend on. Without it, your project is just a collection of random `.move` files."

"Show me how to set it up properly," Loy says, leaning in eagerly.

Mike grins. "Let's build your first properly structured Move package from scratch."

---

## Topics

### Move Package Structure

A standard Move package follows this directory structure:

```
my_project/
├── Move.toml          # Package manifest (required)
├── sources/           # Your Move source files
│   ├── module_one.move
│   └── module_two.move
├── scripts/           # Transaction scripts (optional)
├── tests/             # Test files (optional)
└── build/             # Compiled output (auto-generated)
```

**Key directories:**

- **sources/**: All your `.move` module files go here
- **scripts/**: Entry point scripts for transactions
- **tests/**: Unit test modules
- **build/**: Generated by the compiler, contains bytecode

### The Move.toml File

The `Move.toml` is your package's configuration file. Here's a complete example:

```toml
[package]
name = "MyDeFiProject"
version = "1.0.0"
authors = ["Loy <loy@example.com>"]

[addresses]
myproject = "0x1"
admin = "0x42"

[dev-addresses]
myproject = "0x0"
admin = "0x0"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework", rev = "main" }

[dev-dependencies]
```

**Sections explained:**

| Section              | Purpose                                   |
| -------------------- | ----------------------------------------- |
| `[package]`          | Project metadata (name, version, authors) |
| `[addresses]`        | Named address mappings for production     |
| `[dev-addresses]`    | Address overrides for testing/development |
| `[dependencies]`     | External packages your project uses       |
| `[dev-dependencies]` | Dependencies only for testing             |

### Named Addresses

Named addresses let you write flexible, reusable code:

```move
// Instead of hardcoding addresses:
module 0x1::token { }  // Bad: inflexible

// Use named addresses:
module myproject::token { }  // Good: configurable
```

**Defining named addresses in Move.toml:**

```toml
[addresses]
myproject = "0xcafe"
treasury = "0xbeef"
```

**Using them in your modules:**

```move
module myproject::vault {
    use myproject::token;

    const TREASURY: address = @treasury;

    public fun get_treasury(): address {
        TREASURY
    }
}
```

**The `_` placeholder for compilation:**

```toml
[addresses]
myproject = "_"  # Must be provided at compile/publish time
```

This is useful when the address isn't known until deployment.

### Address Syntax in Move

Move provides two ways to reference addresses:

```move
module myproject::demo {
    // Named address reference (preferred)
    const ADMIN: address = @myproject;

    // Literal hex address
    const LITERAL: address = @0x1;

    // Using std library's named address
    use std::signer;
    use aptos_framework::coin;
}
```

**The `@` symbol** converts an address name or hex literal into an address value.

---

## Closing Scene

Loy saves his `Move.toml` and runs the compiler. For the first time, everything compiles without errors.

"It actually works!" Loy exclaims. "No more 'unbound address' errors!"

Mike gives him a thumbs up. "Now you understand why package structure matters. Every professional Move project starts with a proper `Move.toml`. It's the foundation everything else builds on."

"What's next?" Loy asks, eager to continue.

"Dependencies," Mike replies. "Once you start importing external packages, things get interesting. But that's a lesson for another day."

---

## Summary

- **Move packages** follow a standard structure with `Move.toml`, `sources/`, and optional directories
- **Move.toml** is the package manifest containing metadata, addresses, and dependencies
- **Named addresses** allow flexible module deployment without hardcoding addresses
- **`[addresses]`** defines production address mappings
- **`[dev-addresses]`** provides development/testing overrides
- The **`@` syntax** references named or literal addresses in Move code
- Use **`"_"`** as an address placeholder when the value is provided at compile time
