## üßë‚Äçüíª Background Story

At a Barangay Tech Hub in Quezon City, Neri had prepared a live-coding workshop: ‚ÄúToday, you‚Äôll deploy your first smart contract‚Äîfrom the browser!‚Äù Odessa (‚ÄúDet‚Äù) set up a local Hardhat node and invited learners to connect MetaMask to `http://127.0.0.1:8545`. She clicked ‚ÄúDeploy Simulator,‚Äù pasted a simple ABI/Bytecode artifact, hit **Deploy**, and in seconds a new contract address flashed on screen.

The room buzzed. ‚ÄúAng dali pala!‚Äù said Carlo, a senior high coding club member from Pasig. Odessa smiled: ‚ÄúNo backend, no Truffle CLI‚Äîjust your React app and Ethers.js.‚Äù Next, she opened **Deploy History**, a panel that logged each address and timestamp. Learners saw their contracts accumulate like trophies.

By lunchtime, the class had deployed over 30 instances of `HelloWorld.sol`, each storing a custom greeting. Neri and Odessa high-fived: from pure beginners to ‚Äúreal‚Äù blockchain devs in under 30 minutes. ‚ÄúSimulated,‚Äù yes‚Äîbut the thrill was genuine. Filipino ingenuity turned a sandbox into a production-like pipeline, one click at a time. üöÄüáµüá≠

---

## üìö Theory & Web3 Lecture

1. Why Simulate Deployment in Frontend?

   - Gives beginners a DevOps-lite experience without installing CLI tools.
   - Exposes `ContractFactory`, transaction lifecycle, gas estimation, and receipts.

2. Ethers.js ContractFactory

   - `new ethers.ContractFactory(abi, bytecode, signer)` builds a deployer.
   - `factory.deploy(...constructorArgs)` ‚Üí returns a `Contract` instance with a `.deployTransaction`.
   - `await contract.deployed()` waits for on-chain confirmation.

3. MetaMask as Signer

   - `const provider = new ethers.providers.Web3Provider(window.ethereum)`
   - `await provider.send("eth_requestAccounts", [])` to connect.
   - `const signer = provider.getSigner()` signs the deployment tx.

4. Frontend Architecture

   - **Inputs**: ABI JSON, Bytecode string, constructor arguments
   - **Deploy Button**: triggers `factory.deploy(...)`
   - **Status Handling**: show spinner, catch errors (user reject, gas issues)
   - **Deploy History**: maintain an array of `{ address, timestamp }` in React state (or `localStorage`) and render a list.

5. Gas & Best Practices
   - Estimate gas: `await factory.signer.estimateGas(factory.getDeployTransaction(...))`.
   - Disable the button while deploying.
   - Clean up UI on unmount.
   - Never include private keys in client code‚Äîuse MetaMask or a secure signer.

üîó Further Reading

- Ethers.js Deployment: https://docs.ethers.org/v5/api/contract/contract-factory/
- Ethereum JSON-RPC: https://ethereum.org/en/developers/docs/apis/json-rpc/

---

## üß™ Exercises

### Exercise 1: Build DeploySimulator Component

Problem Statement  
Create `DeploySimulator.js` where users input a greeting string, click **Deploy**, and see the new contract address appear. Use a pre-compiled `HelloWorld.json` artifact containing ABI & bytecode.

**Solidity Contract (`HelloWorld.sol`)**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract HelloWorld {
    string public greeting;
    event Deployed(address indexed deployer, address indexed addr, string greeting);

    constructor(string memory _greeting) {
        greeting = _greeting;
        emit Deployed(msg.sender, address(this), _greeting);
    }

    function setGreeting(string memory _greet) external {
        greeting = _greet;
    }
}
```

**Starter Code (`DeploySimulator.js`)**

```js
import React, { useState } from "react";
import { ethers } from "ethers";
// Precompiled artifact generated by Hardhat or Remix
import HelloWorldArtifact from "../artifacts/HelloWorld.json";

export default function DeploySimulator({ onDeployed }) {
  const [greet, setGreet] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  async function deploy() {
    try {
      setError("");
      setLoading(true);
      // TODO: request accounts
      // TODO: provider = new ethers.providers.Web3Provider(window.ethereum)
      // TODO: signer = provider.getSigner()
      // TODO: factory = new ethers.ContractFactory(artifact.abi, artifact.bytecode, signer)
      // TODO: contract = await factory.deploy(greet)
      // TODO: await contract.deployed()
      // TODO: onDeployed(contract.address)
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <h4>Deploy HelloWorld Contract</h4>
      <input
        placeholder="Greeting message"
        value={greet}
        onChange={(e) => setGreet(e.target.value)}
      />
      <button onClick={deploy} disabled={loading || !greet}>
        {loading ? "Deploying‚Ä¶" : "Deploy"}
      </button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </div>
  );
}
```

To Do List

- [ ] Connect MetaMask via `eth_requestAccounts`.
- [ ] Instantiate `Web3Provider` and `Signer`.
- [ ] Build `ContractFactory` with imported ABI & bytecode.
- [ ] Call `factory.deploy(greet)` and `await contract.deployed()`.
- [ ] Invoke `onDeployed(address)` callback.

**Full Solution**

```js
// DeploySimulator.js
import React, { useState } from "react";
import { ethers } from "ethers";
import HelloWorldArtifact from "../artifacts/HelloWorld.json";

export default function DeploySimulator({ onDeployed }) {
  const [greet, setGreet] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  async function deploy() {
    setError("");
    setLoading(true);
    try {
      await window.ethereum.request({ method: "eth_requestAccounts" });
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();
      const factory = new ethers.ContractFactory(
        HelloWorldArtifact.abi,
        HelloWorldArtifact.bytecode,
        signer
      );
      const contract = await factory.deploy(greet);
      await contract.deployed();
      onDeployed(contract.address);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <h4>Deploy HelloWorld Contract</h4>
      <input
        placeholder="Greeting message"
        value={greet}
        onChange={(e) => setGreet(e.target.value)}
      />
      <button onClick={deploy} disabled={loading || !greet}>
        {loading ? "Deploying‚Ä¶" : "Deploy"}
      </button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </div>
  );
}
```

---

### Exercise 2: Build DeployHistory Component

Problem Statement  
Implement `DeployHistory.js` that receives an array of deployed addresses and timestamps, and renders them in a list. Persist history in `localStorage` so it survives page reload.

**Starter Code (`DeployHistory.js`)**

```js
import React from "react";

export default function DeployHistory({ history }) {
  // TODO: if history is empty, show "No deployments yet."
  // TODO: map history to <li> items: address and new Date(ts).toLocaleString()
  return <ul>{/* your list here */}</ul>;
}
```

To Do List

- [ ] Handle empty `history` gracefully.
- [ ] Display each entry with address and readable date/time.
- [ ] Style entries in a scrollable box.

**Full Solution**

```js
// DeployHistory.js
import React from "react";

export default function DeployHistory({ history }) {
  if (!history.length) {
    return <p>No deployments yet.</p>;
  }
  return (
    <div style={{ maxHeight: 200, overflowY: "auto" }}>
      <ul>
        {history.map((h, i) => (
          <li key={i} style={{ marginBottom: 8 }}>
            <code>{h.address}</code>
            <br />
            <small>{new Date(h.timestamp).toLocaleString()}</small>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### Exercise 3: Integrate Simulator & History in App

Problem Statement  
Create `App.js` that ties `DeploySimulator` and `DeployHistory` together. Store history in React state and `localStorage`.

**Starter Code (`App.js`)**

```js
import React, { useState, useEffect } from "react";
import DeploySimulator from "./DeploySimulator";
import DeployHistory from "./DeployHistory";

export default function App() {
  const [history, setHistory] = useState([]);

  useEffect(() => {
    // TODO: load history from localStorage
  }, []);

  function handleDeployed(address) {
    // TODO: append { address, timestamp: Date.now() } to state & localStorage
  }

  return (
    <div>
      <h2>Contract Deployment Simulator</h2>
      <DeploySimulator onDeployed={handleDeployed} />
      <h4>Deploy History</h4>
      <DeployHistory history={history} />
    </div>
  );
}
```

To Do List

- [ ] On mount, read `localStorage.getItem("deployHistory")` and parse JSON.
- [ ] In `handleDeployed`, update state and write back to `localStorage`.
- [ ] Pass history array to `DeployHistory`.

**Full Solution**

```js
// App.js
import React, { useState, useEffect } from "react";
import DeploySimulator from "./DeploySimulator";
import DeployHistory from "./DeployHistory";

const STORAGE_KEY = "deployHistory";

export default function App() {
  const [history, setHistory] = useState([]);

  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      setHistory(JSON.parse(saved));
    }
  }, []);

  function handleDeployed(address) {
    const entry = { address, timestamp: Date.now() };
    const updated = [entry, ...history];
    setHistory(updated);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
  }

  return (
    <div style={{ padding: 24, fontFamily: "sans-serif" }}>
      <h2>Contract Deployment Simulator</h2>
      <DeploySimulator onDeployed={handleDeployed} />
      <h4>Deploy History</h4>
      <DeployHistory history={history} />
    </div>
  );
}
```

---

## ‚úÖ Test Cases

Create `__tests__/DeploySimulator.test.js`:

```js
// __tests__/DeploySimulator.test.js
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import DeploySimulator from "../DeploySimulator";
import { ethers } from "ethers";

jest.mock("ethers");

describe("DeploySimulator Component", () => {
  const fakeProvider = {};
  const fakeSigner = {};
  const fakeFactory = { deploy: jest.fn() };
  const fakeContract = { deployed: jest.fn() };

  beforeAll(() => {
    global.window.ethereum = {
      request: jest.fn().mockResolvedValue(["0xABC"]),
    };
    ethers.providers.Web3Provider = jest.fn().mockReturnValue(fakeProvider);
    fakeProvider.getSigner = jest.fn().mockReturnValue(fakeSigner);
    ethers.ContractFactory = jest.fn().mockImplementation(() => fakeFactory);
  });

  it("deploys contract and calls onDeployed", async () => {
    const onDeployed = jest.fn();
    // Mock deploy flow
    fakeContract.address = "0xDEAD";
    fakeFactory.deploy.mockResolvedValue(fakeContract);
    fakeContract.deployed.mockResolvedValue();

    render(<DeploySimulator onDeployed={onDeployed} />);
    fireEvent.change(screen.getByPlaceholderText("Greeting message"), {
      target: { value: "Hello Test" },
    });
    fireEvent.click(screen.getByText("Deploy"));

    await waitFor(() =>
      expect(fakeFactory.deploy).toHaveBeenCalledWith("Hello Test")
    );
    await waitFor(() => expect(onDeployed).toHaveBeenCalledWith("0xDEAD"));
  });

  it("shows error when user rejects", async () => {
    fakeFactory.deploy.mockRejectedValue(new Error("User denied"));
    render(<DeploySimulator onDeployed={() => {}} />);
    fireEvent.change(screen.getByPlaceholderText("Greeting message"), {
      target: { value: "Oops" },
    });
    fireEvent.click(screen.getByText("Deploy"));
    expect(await screen.findByText("User denied")).toBeInTheDocument();
  });
});
```

Add to `jest.config.js`:

```js
module.exports = {
  testEnvironment: "jsdom",
  moduleNameMapper: {
    "\\.(css|scss)$": "identity-obj-proxy",
  },
};
```

---

## üåü Closing Story

By the end of the workshop, each learner had their own ‚ÄúHelloWorld‚Äù contract address listed in **Deploy History**‚Äîproof that they‚Äôd just deployed code to a blockchain, all from a pure-frontend sandbox. Neri and Odessa handed out stickers: ‚ÄúI Deployed with React.js & Ethers.js.‚Äù For many, it was the spark that ignited a Web3 journey. Next up: front-end upgrades to support constructor overloading and live ABI imports. Filipino dev power‚Äîdeploying the future, one click at a time. üáµüá≠üî•
