# Deploy Smart Contract via UI Activity

## Initial Code

```js
// DeploySimulator.js - Starter Code
import React, { useState } from "react";
import { ethers } from "ethers";
import HelloWorldArtifact from "../artifacts/HelloWorld.json";

export default function DeploySimulator({ onDeployed }) {
  const [greet, setGreet] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  async function deploy() {
    try {
      setError("");
      setLoading(true);

      // TODO: Task 1 - Connect to MetaMask and get signer
      // @note Request account access using eth_requestAccounts,
      // create a Web3Provider from window.ethereum, and get the signer

      // TODO: Task 2 - Create ContractFactory with artifact
      // @note Use ethers.ContractFactory with the ABI, bytecode, and signer

      // TODO: Task 3 - Deploy contract and wait for confirmation
      // @note Call factory.deploy() with the greeting, wait for deployment,
      // and invoke the onDeployed callback with the contract address
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <h4>Deploy HelloWorld Contract</h4>
      <input
        placeholder="Greeting message"
        value={greet}
        onChange={(e) => setGreet(e.target.value)}
      />
      <button onClick={deploy} disabled={loading || !greet}>
        {loading ? "Deploying…" : "Deploy"}
      </button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </div>
  );
}
```

**Time Allotment: 15 minutes**

## Tasks for Learners

Topics Covered: `Web3Provider`, Signer, `ContractFactory`, Contract artifacts (ABI & bytecode), Deployment confirmation, Callback pattern

---

### Task 1: Connect to MetaMask and Get Signer

Request account access from MetaMask using `eth_requestAccounts`. Then create a `Web3Provider` from `window.ethereum` and obtain a signer. The signer is required because deployment is a write operation that needs transaction signing.

```js
await window.ethereum.request({ method: "eth_requestAccounts" });
const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();
```

---

### Task 2: Create ContractFactory with Artifact

Use `ethers.ContractFactory` to prepare for deployment. Pass the ABI (contract interface), bytecode (compiled contract code), and signer. The factory object knows how to deploy new instances of the contract.

```js
const factory = new ethers.ContractFactory(
  HelloWorldArtifact.abi,
  HelloWorldArtifact.bytecode,
  signer
);
```

---

### Task 3: Deploy Contract and Wait for Confirmation

Call `factory.deploy()` with the constructor argument (greeting message). This sends the deployment transaction. Then call `contract.deployed()` to wait for on-chain confirmation. Finally, invoke the `onDeployed` callback with the new contract address.

```js
const contract = await factory.deploy(greet);
await contract.deployed();
onDeployed(contract.address);
```

---

## Breakdown of the Activity

**Variables Defined:**

- `greet`: State variable storing the user-entered greeting message. This value is passed to the contract constructor during deployment.

- `loading`: Boolean state tracking whether deployment is in progress. Used to disable the button and show "Deploying…" text to prevent duplicate submissions.

- `error`: State variable storing any error message from failed deployment. Displayed in red text below the button.

- `HelloWorldArtifact`: Imported JSON file containing the compiled contract's ABI (Application Binary Interface) and bytecode. Generated by Hardhat/Truffle during compilation.

- `factory`: A `ContractFactory` instance that knows how to deploy the HelloWorld contract. Created with ABI, bytecode, and signer.

- `contract`: The deployed contract instance returned by `factory.deploy()`. Contains the contract address and methods for interaction.

**Key Functions:**

- `deploy()`:
  The main async function handling the entire deployment workflow. First requests MetaMask access and creates provider/signer. Then creates a ContractFactory with the compiled artifact. Deploys the contract with the greeting argument and waits for confirmation. Finally calls the parent callback with the new address. Wrapped in try/catch/finally for proper error handling and loading state management.

- `ethers.ContractFactory(abi, bytecode, signer)`:
  Creates a factory for deploying new contract instances. The ABI defines the contract interface (functions, events). The bytecode is the compiled EVM code. The signer authorizes and pays for the deployment transaction.

- `factory.deploy(...args)`:
  Sends a deployment transaction to the network. Arguments are passed to the contract's constructor. Returns a Contract object immediately, but the contract isn't confirmed yet.

- `contract.deployed()`:
  Returns a Promise that resolves when the deployment transaction is mined and the contract is live on-chain. Essential for knowing when the contract is ready to use.

- `onDeployed(address)`:
  Callback prop passed from the parent component. Called with the new contract address after successful deployment. Allows the parent to store or display the deployed address.
